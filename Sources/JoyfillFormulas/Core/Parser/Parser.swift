import Foundation

/// Represents a token generated by the Lexer.
struct Token: Equatable {
    enum TokenType: Equatable {
        case identifier // e.g., function names like MAP, IF, or field references like price, quantity
        case numberLiteral // e.g., 123, 45.6
        case stringLiteral // e.g., "hello", "x"
        case booleanLiteral // e.g., true, false
        case `operator` // e.g., +, -, *, /, ==, !=, &&, ||
        case leftParen, rightParen // (, )
        case leftBracket, rightBracket // [, ]
        case leftBrace, rightBrace // {, }
        case comma // ,
        case dot // .
        case colon // :
        case eof // End of formula
    }

    let type: TokenType
    let lexeme: String // The actual text of the token
}

/// Simple Lexer to tokenize a formula string.
struct Lexer {
    private let input: String
    private var currentIndex: String.Index

    // Define all valid operators (single and double character)
    private let knownOperators: Set<String> = [
        "+", "-", "*", "/", // Arithmetic
        "==", "!=", ">", "<", ">=", "<=", // Comparison
        "&&", "||", "!", // Logical (! added for potential future NOT)
        "=", // Keep single = for now (e.g., for potential future assignment or just strict equality)
        "->" // Arrow operator for lambda functions
    ]

    init(input: String) {
        self.input = input
        self.currentIndex = input.startIndex
    }

    mutating func tokenize() -> Result<[Token], FormulaError> {
        var tokens: [Token] = []

        while currentIndex < input.endIndex {
            let char = input[currentIndex]

            if char.isWhitespace {
                advance()
            } else if char == "(" {
                tokens.append(Token(type: .leftParen, lexeme: String(char)))
                advance()
            } else if char == ")" {
                tokens.append(Token(type: .rightParen, lexeme: String(char)))
                advance()
            } else if char == "[" {
                tokens.append(Token(type: .leftBracket, lexeme: String(char)))
                advance()
            } else if char == "]" {
                tokens.append(Token(type: .rightBracket, lexeme: String(char)))
                advance()
            } else if char == "{" {
                tokens.append(Token(type: .leftBrace, lexeme: String(char)))
                advance()
            } else if char == "}" {
                tokens.append(Token(type: .rightBrace, lexeme: String(char)))
                advance()
            } else if char == "," {
                tokens.append(Token(type: .comma, lexeme: String(char)))
                advance()
            } else if char == ":" {
                tokens.append(Token(type: .colon, lexeme: String(char)))
                advance()
            } else if char == "\"" { // String literal start (double quotes)
                advance() // Consume '"'
                let start = currentIndex
                while currentIndex < input.endIndex && input[currentIndex] != "\"" {
                    advance()
                }
                
                // Check if we found the closing quote or ran off the end
                guard currentIndex < input.endIndex else {
                    // This should be the failure path for unterminated strings
                    return .failure(.syntaxError("Unterminated string literal starting at: \(String(describing: input.suffix(from: start)))")) // Return immediately
                }
                
                // If we are here, input[currentIndex] must be '"' 
                let lexeme = String(input[start..<currentIndex])
                tokens.append(Token(type: .stringLiteral, lexeme: lexeme))
                advance() // Consume closing '"'
            } else if char == "'" { // String literal start (single quotes)
                advance() // Consume "'"
                let start = currentIndex
                while currentIndex < input.endIndex && input[currentIndex] != "'" {
                    advance()
                }
                
                // Check if we found the closing quote or ran off the end
                guard currentIndex < input.endIndex else {
                    // This should be the failure path for unterminated strings
                    return .failure(.syntaxError("Unterminated string literal starting at: \(String(describing: input.suffix(from: start)))")) // Return immediately
                }
                
                // If we are here, input[currentIndex] must be "'" 
                let lexeme = String(input[start..<currentIndex])
                tokens.append(Token(type: .stringLiteral, lexeme: lexeme))
                advance() // Consume closing "'"
            } else if char.isLetter || char == "_" { // Identifier, Boolean, or Field Reference
                let start = currentIndex
                while currentIndex < input.endIndex && (input[currentIndex].isLetter || input[currentIndex].isNumber || input[currentIndex] == "_") {
                    advance()
                }
                let lexeme = String(input[start..<currentIndex])
                if lexeme.lowercased() == "true" || lexeme.lowercased() == "false" {
                     tokens.append(Token(type: .booleanLiteral, lexeme: lexeme))
                } else if lexeme.lowercased() == "null" {
                     tokens.append(Token(type: .identifier, lexeme: lexeme)) // We'll handle null as a special identifier for now
                } else {
                     tokens.append(Token(type: .identifier, lexeme: lexeme))
                }
            } else if char.isNumber || (char == "-" && peek()?.isNumber ?? false) {
                // Note: We handle (char == "." && peek()?.isNumber) specially in the dot section to avoid conflicts with property access
                 let start = currentIndex
                 advance()
                 var hasDecimalPoint = false
                 
                 while currentIndex < input.endIndex && input[currentIndex].isNumber {
                     advance()
                 }
                 
                 // Check for decimal point only if we haven't already seen one and it's followed by more numbers
                 if !hasDecimalPoint && currentIndex < input.endIndex && input[currentIndex] == "." {
                     let nextIndex = input.index(after: currentIndex)
                     if nextIndex < input.endIndex && input[nextIndex].isNumber {
                         // This is a valid decimal number like 3.14
                         hasDecimalPoint = true
                         advance() // consume the dot
                         while currentIndex < input.endIndex && input[currentIndex].isNumber {
                             advance()
                         }
                     }
                     // If dot is not followed by a number, don't consume it (for table access like 0.name)
                 }
                 
                 let lexeme = String(input[start..<currentIndex])
                 if Double(lexeme) != nil {
                    tokens.append(Token(type: .numberLiteral, lexeme: lexeme))
                 } else {
                    return .failure(.syntaxError("Invalid number format: \(lexeme)"))
                 }
            } else if char == "." {
                // Check if this could be a decimal number starting with dot (like .95)
                // Only treat it as a decimal if we're NOT after something that can have property access
                if let nextChar = peek(), nextChar.isNumber {
                    // Check if the last token can be followed by property access
                    let lastToken = tokens.last
                    let canHavePropertyAccess = (lastToken != nil) && (
                                                 lastToken?.type == .identifier || 
                                                 lastToken?.type == .numberLiteral ||
                                                 lastToken?.type == .rightParen ||
                                                 lastToken?.type == .rightBracket)
                    
                    if !canHavePropertyAccess {
                        // This is a decimal number like .95, parse it as a number
                        let start = currentIndex
                        advance() // consume the dot
                        
                        while currentIndex < input.endIndex && input[currentIndex].isNumber {
                            advance()
                        }
                        
                        let lexeme = String(input[start..<currentIndex])
                        if Double(lexeme) != nil {
                            tokens.append(Token(type: .numberLiteral, lexeme: lexeme))
                        } else {
                            return .failure(.syntaxError("Invalid number format: \(lexeme)"))
                        }
                        continue // Skip the rest and continue tokenizing
                    }
                }
                
                // Otherwise treat dots as property access for table row syntax like products.0.name
                tokens.append(Token(type: .dot, lexeme: String(char)))
                advance()
            } else if isOperatorStart(char) {
                let firstChar = char
                var finalLexeme: String? = nil

                // Prioritize two-character operators
                if let nextChar = peek() {
                    let twoChars = String(firstChar) + String(nextChar)
                    if knownOperators.contains(twoChars) { // Use knownOperators check
                        finalLexeme = twoChars
                        advance() // Consume first char
                        advance() // Consume second char
                    }
                }

                // If no two-character operator was matched, try single character
                if finalLexeme == nil {
                    let singleChar = String(firstChar)
                    if knownOperators.contains(singleChar) {
                        finalLexeme = singleChar
                        advance() // Consume only the first char
                    } else {
                         // If neither a known two-char nor a known single-char op starts here
                         return .failure(.syntaxError("Unknown operator sequence starting with: \(firstChar)"))
                    }
                }

                // Check if we successfully formed a known operator (1 or 2 chars)
                if let lexeme = finalLexeme {
                    tokens.append(Token(type: .operator, lexeme: lexeme))
                } else {
                    // Failsafe, should be unreachable due to checks above
                    return .failure(.syntaxError("Operator lexing failed unexpectedly at: \(firstChar)")) 
                }
            } else {
                return .failure(.syntaxError("Unexpected character: \(char)"))
            }
        }

        tokens.append(Token(type: .eof, lexeme: ""))
        return .success(tokens)
    }

    private mutating func advance() {
        if currentIndex < input.endIndex {
            currentIndex = input.index(after: currentIndex)
        }
    }

    private func peek() -> Character? {
        guard currentIndex < input.endIndex else { return nil }
        let nextIndex = input.index(after: currentIndex)
        guard nextIndex < input.endIndex else { return nil }
        return input[nextIndex]
    }

    private func isOperatorStart(_ char: Character) -> Bool {
        return "+-*/=><!&|-".contains(char)
    }
}


/// Parses a formula string into an Abstract Syntax Tree (AST).
public class Parser {

    private var tokens: [Token] = []
    private var currentIndex: Int = 0
    private let functionRegistry: FunctionRegistry

    public init(functionRegistry: FunctionRegistry = FunctionRegistry()) {
        self.functionRegistry = functionRegistry
    }

    /// Parses the given formula string.
    public func parse(formula: String) -> Result<ASTNode, FormulaError> {
        // 1. Tokenize
        var lexer = Lexer(input: formula)
        let tokenResult = lexer.tokenize()

        switch tokenResult {
        case .success(let tokens):
            self.tokens = tokens
            self.currentIndex = 0

            // 2. Parse
            let parseResult = parseExpression() // Start parsing the main expression

            // 3. Check for leftover tokens (syntax error)
            if case .success = parseResult, currentToken()?.type != .eof {
                 return .failure(.syntaxError("Unexpected token after expression: \(currentToken()?.lexeme ?? "nil")"))
            }

            return parseResult

        case .failure(let error):
            return .failure(error)
        }
    }

    // --- Recursive Descent Parsing Methods (Updated Precedence) ---

    // expression -> logicalOr
    private func parseExpression() -> Result<ASTNode, FormulaError> {
        return parseLogicalOr()
    }

    // logicalOr -> logicalAnd ( '||' logicalAnd )*
    private func parseLogicalOr() -> Result<ASTNode, FormulaError> {
        var leftResult = parseLogicalAnd()
        while let token = currentToken(), token.type == .operator && token.lexeme == "||" {
            let op = token.lexeme
            advance() // Consume ||
            let rightResult = parseLogicalAnd()
            leftResult = combineResults(op: op, leftResult: leftResult, rightResult: rightResult)
        }
        return leftResult
    }

    // logicalAnd -> equality ( '&&' equality )*
    private func parseLogicalAnd() -> Result<ASTNode, FormulaError> {
        var leftResult = parseEquality()
        while let token = currentToken(), token.type == .operator && token.lexeme == "&&" {
            let op = token.lexeme
            advance() // Consume &&
            let rightResult = parseEquality()
             leftResult = combineResults(op: op, leftResult: leftResult, rightResult: rightResult)
       }
        return leftResult
    }

    // equality -> comparison ( ( '==' | '!=' ) comparison )*
    private func parseEquality() -> Result<ASTNode, FormulaError> {
        var leftResult = parseComparison()
        while let token = currentToken(), token.type == .operator && (token.lexeme == "==" || token.lexeme == "!=") {
            let op = token.lexeme
            advance() // Consume operator
            let rightResult = parseComparison()
            leftResult = combineResults(op: op, leftResult: leftResult, rightResult: rightResult)
        }
        return leftResult
    }

    // comparison -> additive ( ( '>' | '<' | '>=' | '<=' ) additive )*
    private func parseComparison() -> Result<ASTNode, FormulaError> {
        var leftResult = parseAdditive()
        while let token = currentToken(), token.type == .operator && (token.lexeme == ">" || token.lexeme == "<" || token.lexeme == ">=" || token.lexeme == "<=") {
            let op = token.lexeme
            advance() // Consume operator
            let rightResult = parseAdditive()
            leftResult = combineResults(op: op, leftResult: leftResult, rightResult: rightResult)
        }
        return leftResult
    }

    // additive -> term ( ( '+' | '-' ) term )*
    private func parseAdditive() -> Result<ASTNode, FormulaError> {
        var leftResult = parseTerm()
        while let token = currentToken(), token.type == .operator && (token.lexeme == "+" || token.lexeme == "-") {
             let op = token.lexeme
             advance()
             let rightResult = parseTerm()
             leftResult = combineResults(op: op, leftResult: leftResult, rightResult: rightResult)
        }
        return leftResult
    }

    // term -> factor ( ( '*' | '/' ) factor )*
    private func parseTerm() -> Result<ASTNode, FormulaError> {
        var leftResult = parseFactor()
        while let token = currentToken(), token.type == .operator && (token.lexeme == "*" || token.lexeme == "/") {
             let op = token.lexeme
             advance()
             let rightResult = parseFactor() // Keep calling factor for right operand
             leftResult = combineResults(op: op, leftResult: leftResult, rightResult: rightResult)
        }
        return leftResult
    }

    // factor -> unary
    private func parseFactor() -> Result<ASTNode, FormulaError> {
        return parseUnary() // Factor now delegates to Unary
    }

    // unary -> ( '-' | '!' ) unary | postfix 
    private func parseUnary() -> Result<ASTNode, FormulaError> {
        if let token = currentToken(), token.type == .operator && (token.lexeme == "-" || token.lexeme == "!") {
            let op = token.lexeme
            advance() // Consume '-' or '!'
            let operandResult = parseUnary() // Recursively call unary for nested operators like --1 or !!true
            
            switch operandResult {
            case .success(let operandNode):
                return .success(.prefixOperation(operator: op, operand: operandNode))
            case .failure(let error):
                return .failure(error)
            }
        } else {
            // If no unary operator, parse the postfix expression
            return parsePostfix()
        }
    }

    // postfix -> primary ( '[' expression ']' | '.' identifier )*
    private func parsePostfix() -> Result<ASTNode, FormulaError> {
        var result = parsePrimary()
        
        while let token = currentToken() {
            if token.type == .leftBracket {
                // Array access: expr[index]
                advance() // Consume '['
                let indexResult = parseExpression()
                guard case .success(let indexNode) = indexResult else {
                    return indexResult
                }
                guard currentToken()?.type == .rightBracket else {
                    return .failure(.syntaxError("Expected ']' after array index, found \(currentToken()?.lexeme ?? "nil")"))
                }
                advance() // Consume ']'
                
                guard case .success(let arrayNode) = result else {
                    return result
                }
                result = .success(.arrayAccess(array: arrayNode, index: indexNode))
                
            } else if token.type == .dot {
                // Property access: expr.property or expr.0 (for table row access)
                advance() // Consume '.'
                guard let propertyToken = currentToken(), 
                      propertyToken.type == .identifier || propertyToken.type == .numberLiteral else {
                    return .failure(.syntaxError("Expected property name after '.', found \(currentToken()?.lexeme ?? "nil")"))
                }
                advance() // Consume property name
                
                guard case .success(let objectNode) = result else {
                    return result
                }
                result = .success(.propertyAccess(object: objectNode, property: propertyToken.lexeme))
                
            } else {
                // No more postfix operators
                break
            }
        }
        
        return result
    }

    // primary -> Number | String | Boolean | Reference | functionCall | '(' expression ')' | '[' arrayLiteral ']'
    private func parsePrimary() -> Result<ASTNode, FormulaError> {
        guard let token = currentToken() else {
            return .failure(.syntaxError("Unexpected end of input while parsing primary expression."))
        }

        switch token.type {
        case .numberLiteral:
            advance()
            guard let value = Double(token.lexeme) else { return .failure(.syntaxError("Invalid number literal: \(token.lexeme)")) }
            return .success(.literal(.number(value)))

        case .stringLiteral:
            advance()
            return .success(.literal(.string(token.lexeme)))

        case .booleanLiteral:
             advance()
             let value = token.lexeme.lowercased() == "true"
             return .success(.literal(.boolean(value)))

        case .identifier:
            let tokenName = token.lexeme
            
            // Check if it's the null literal
            if tokenName.lowercased() == "null" {
                advance()
                return .success(.literal(.null))
            }
            
            // Check if it's the undefined literal (treat as undefined)
            if tokenName.lowercased() == "undefined" {
                advance()
                return .success(.literal(.undefined))
            }
            
            // Check if it's a function call (identifier followed by '(')
            if let nextToken = peekToken(), nextToken.type == .leftParen {
                // Verify it's a registered function
                if functionRegistry.lookup(name: tokenName) != nil {
                    return parseFunctionCall()
                } else {
                    return .failure(.syntaxError("Unknown function: \(tokenName)"))
                }
            } else {
                // Treat as field reference
                advance()
                return .success(.reference(tokenName))
            }

        case .leftParen:
            // Check for lambda expression: (param) → body or multiple params: (param1, param2) → body
            if isLambdaExpression() {
                return parseLambda()
            } else {
                // Regular parenthesized expression
                advance()
                let expressionResult = parseExpression()
                guard case .success = expressionResult else { return expressionResult }
                guard currentToken()?.type == .rightParen else { return .failure(.syntaxError("Expected ')' after parenthesized expression, found \(currentToken()?.lexeme ?? "nil")")) }
                advance()
                return expressionResult
            }

        case .leftBracket:
             return parseArrayLiteral()

        case .leftBrace:
             return parseObjectLiteral()

        default:
             // Check if it's an operator being used incorrectly (e.g., as a primary value)
             if token.type == .operator {
                  return .failure(.syntaxError("Operator '\(token.lexeme)' cannot be used as a value."))
             }
            return .failure(.syntaxError("Unexpected token while parsing primary expression: \(token.lexeme)"))
        }
    }

    private func parseFunctionCall() -> Result<ASTNode, FormulaError> {
        guard let nameToken = currentToken(), nameToken.type == .identifier else {
            return .failure(.syntaxError("Internal error: Expected function name identifier."))
        }
        advance() // Consume identifier

        guard currentToken()?.type == .leftParen else {
            return .failure(.syntaxError("Expected '(' after function name \(nameToken.lexeme), found \(currentToken()?.lexeme ?? "nil")"))
        }
        advance() // Consume '('

        var arguments: [ASTNode] = []
        if currentToken()?.type != .rightParen {
            while true {
                let argResult = parseExpression()
                switch argResult {
                case .success(let argNode):
                    arguments.append(argNode)
                case .failure(let error):
                    return .failure(error)
                }
                if currentToken()?.type == .rightParen { break }
                else if currentToken()?.type == .comma { advance() }
                else { return .failure(.syntaxError("Expected ',' or ')' in function arguments, found \(currentToken()?.lexeme ?? "nil")")) }
            }
        }

        guard currentToken()?.type == .rightParen else {
            return .failure(.syntaxError("Expected ')' to end function call \(nameToken.lexeme), found \(currentToken()?.lexeme ?? "nil")"))
        }
        advance() // Consume ')'
                
        return .success(.functionCall(name: nameToken.lexeme, arguments: arguments))
    }

    private func parseArrayLiteral() -> Result<ASTNode, FormulaError> {
        guard currentToken()?.type == .leftBracket else {
             return .failure(.syntaxError("Expected '[' to start array literal."))
        }
        advance() // Consume '['
        
        var elementNodes: [ASTNode] = []

        if currentToken()?.type != .rightBracket {
            while true {
                 let elementResult = parseExpression()
                 switch elementResult {
                 case .success(let elementNode):
                    elementNodes.append(elementNode)
                 case .failure(let error):
                     return .failure(error)
                 }
                 if currentToken()?.type == .rightBracket { break }
                 else if currentToken()?.type == .comma { 
                     advance() // Consume comma
                     // Check for trailing comma (comma followed by ']')
                     if currentToken()?.type == .rightBracket { break }
                 }
                 else { return .failure(.syntaxError("Expected ',' or ']' in array literal, found \(currentToken()?.lexeme ?? "nil")")) }
            }
        }

        guard currentToken()?.type == .rightBracket else {
             return .failure(.syntaxError("Expected ']' to end array literal, found \(currentToken()?.lexeme ?? "nil")"))
        }
        advance() // Consume ']'
        return .success(.arrayLiteral(elementNodes))
    }

    private func parseObjectLiteral() -> Result<ASTNode, FormulaError> {
        guard currentToken()?.type == .leftBrace else {
            return .failure(.syntaxError("Expected '{' to start object literal."))
        }
        advance() // Consume '{'
        
        var keyValuePairs: [(String, ASTNode)] = []

        if currentToken()?.type != .rightBrace {
            while true {
                // Parse the key (must be an identifier or string literal)
                guard let keyToken = currentToken() else {
                    return .failure(.syntaxError("Expected object key, found end of input"))
                }
                
                let key: String
                switch keyToken.type {
                case .identifier:
                    key = keyToken.lexeme
                    advance()
                case .stringLiteral:
                    key = keyToken.lexeme
                    advance()
                default:
                    return .failure(.syntaxError("Expected identifier or string for object key, found \(keyToken.lexeme)"))
                }
                
                guard currentToken()?.type == .colon else {
                    return .failure(.syntaxError("Expected ':' after object key, found \(currentToken()?.lexeme ?? "nil")"))
                }
                advance() // Consume ':'
                
                let valueResult = parseExpression()
                switch valueResult {
                case .success(let valueNode):
                    keyValuePairs.append((key, valueNode))
                case .failure(let error):
                    return .failure(error)
                }
                
                if currentToken()?.type == .rightBrace { break }
                else if currentToken()?.type == .comma { advance() }
                else { return .failure(.syntaxError("Expected ',' or '}' in object literal, found \(currentToken()?.lexeme ?? "nil")")) }
            }
        }

        guard currentToken()?.type == .rightBrace else {
            return .failure(.syntaxError("Expected '}' to end object literal, found \(currentToken()?.lexeme ?? "nil")"))
        }
        advance() // Consume '}'
        return .success(.objectLiteral(keyValuePairs))
    }

    // Helper to combine results for binary operations
    private func combineResults(op: String, leftResult: Result<ASTNode, FormulaError>, rightResult: Result<ASTNode, FormulaError>) -> Result<ASTNode, FormulaError> {
         switch (leftResult, rightResult) {
         case (.success(let leftNode), .success(let rightNode)):
             return .success(.infixOperation(operator: op, left: leftNode, right: rightNode))
         case (.failure(let error), _): return .failure(error)
         case (_, .failure(let error)): return .failure(error)
         }
    }

    // --- Parsing Helper Methods ---

    /// Checks if the current position is the start of a lambda expression
    private func isLambdaExpression() -> Bool {
        guard currentToken()?.type == .leftParen else { return false }
        
        // Look ahead to find arrow operator
        var i = currentIndex + 1
        var parenCount = 1
        
        while i < tokens.count && parenCount > 0 {
            let token = tokens[i]
            if token.type == .leftParen {
                parenCount += 1
            } else if token.type == .rightParen {
                parenCount -= 1
            } else if parenCount == 0 && token.type == .operator && token.lexeme == "->" {
                return true
            }
            i += 1
        }
        
        // Check if the next token after closing paren is arrow
        if parenCount == 0 && i < tokens.count {
            return tokens[i].type == .operator && tokens[i].lexeme == "->"
        }
        
        return false
    }
    
    /// Parses a lambda expression: (param1, param2) -> body
    private func parseLambda() -> Result<ASTNode, FormulaError> {
        guard currentToken()?.type == .leftParen else {
            return .failure(.syntaxError("Expected '(' to start lambda parameters"))
        }
        advance() // Consume '('
        
        var parameters: [String] = []
        
        // Parse parameter list
        if currentToken()?.type != .rightParen {
            while true {
                guard let token = currentToken(), token.type == .identifier else {
                    return .failure(.syntaxError("Expected parameter name in lambda, found \(currentToken()?.lexeme ?? "nil")"))
                }
                parameters.append(token.lexeme)
                advance()
                
                if currentToken()?.type == .rightParen {
                    break
                } else if currentToken()?.type == .comma {
                    advance()
                } else {
                    return .failure(.syntaxError("Expected ',' or ')' in lambda parameters, found \(currentToken()?.lexeme ?? "nil")"))
                }
            }
        }
        
        guard currentToken()?.type == .rightParen else {
            return .failure(.syntaxError("Expected ')' after lambda parameters, found \(currentToken()?.lexeme ?? "nil")"))
        }
        advance() // Consume ')'
        
        // Parse arrow operator
        guard let arrowToken = currentToken(), arrowToken.type == .operator && arrowToken.lexeme == "->" else {
            return .failure(.syntaxError("Expected '->' after lambda parameters, found \(currentToken()?.lexeme ?? "nil")"))
        }
        advance() // Consume '->'
        
        // Parse lambda body
        let bodyResult = parseExpression()
        switch bodyResult {
        case .success(let bodyNode):
            return .success(.lambda(parameters: parameters, body: bodyNode))
        case .failure(let error):
            return .failure(error)
        }
    }

    private func currentToken() -> Token? {
        guard currentIndex < tokens.count else { return nil }
        return tokens[currentIndex]
    }

     private func peekToken() -> Token? {
         let nextIndex = currentIndex + 1
         guard nextIndex < tokens.count else { return nil }
         return tokens[nextIndex]
     }

    private func advance() {
        if currentIndex < tokens.count {
            currentIndex += 1
        }
    }
}


