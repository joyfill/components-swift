import Foundation

/// Represents a node in the Abstract Syntax Tree (AST) generated by the parser.
public indirect enum ASTNode: Equatable {
    case literal(FormulaValue) // Represents a fully resolved literal value
    case reference(String) // e.g., "fieldName" or "table.A1"
    case functionCall(name: String, arguments: [ASTNode])
    case infixOperation(operator: String, left: ASTNode, right: ASTNode)
    case prefixOperation(operator: String, operand: ASTNode) // For future use (e.g., NOT, unary minus)
    case arrayLiteral([ASTNode]) // Represents an array definition like [expr1, expr2]
    case objectLiteral([(String, ASTNode)]) // Represents an object definition like {key1: value1, key2: value2}
    case lambda(parameters: [String], body: ASTNode) // Lambda expressions like (item) -> item * 2
    case arrayAccess(array: ASTNode, index: ASTNode) // Array indexing like fruits[0]
    case propertyAccess(object: ASTNode, property: String) // Object property access like user.name
}

// Explicit Equatable implementation to handle objectLiteral case
extension ASTNode {
    public static func == (lhs: ASTNode, rhs: ASTNode) -> Bool {
        switch (lhs, rhs) {
        case (.literal(let lValue), .literal(let rValue)):
            return lValue == rValue
        case (.reference(let lName), .reference(let rName)):
            return lName == rName
        case (.functionCall(let lName, let lArgs), .functionCall(let rName, let rArgs)):
            return lName == rName && lArgs == rArgs
        case (.infixOperation(let lOp, let lLeft, let lRight), .infixOperation(let rOp, let rLeft, let rRight)):
            return lOp == rOp && lLeft == rLeft && lRight == rRight
        case (.prefixOperation(let lOp, let lOperand), .prefixOperation(let rOp, let rOperand)):
            return lOp == rOp && lOperand == rOperand
        case (.arrayLiteral(let lElements), .arrayLiteral(let rElements)):
            return lElements == rElements
        case (.objectLiteral(let lPairs), .objectLiteral(let rPairs)):
            guard lPairs.count == rPairs.count else { return false }
            for (lPair, rPair) in zip(lPairs, rPairs) {
                if lPair.0 != rPair.0 || lPair.1 != rPair.1 {
                    return false
                }
            }
            return true
        case (.lambda(let lParams, let lBody), .lambda(let rParams, let rBody)):
            return lParams == rParams && lBody == rBody
        case (.arrayAccess(let lArray, let lIndex), .arrayAccess(let rArray, let rIndex)):
            return lArray == rArray && lIndex == rIndex
        case (.propertyAccess(let lObject, let lProperty), .propertyAccess(let rObject, let rProperty)):
            return lObject == rObject && lProperty == rProperty
        default:
            return false
        }
    }
}

// Note: We use `indirect` to allow recursive definition (e.g., operations containing other operations or array literals containing expressions).
